{"version":3,"file":"Vector2-CYfU2A-a.js","sources":["../src/Engine/Component.js","../src/Engine/RGB.js","../src/Engine/Rotation.js","../src/Engine/Vector2.js"],"sourcesContent":["class Component {\r\n  options = {};\r\n  active = true;\r\n  entity = null;\r\n\r\n  constructor(options) {\r\n    if (options) {\r\n      this.options = { ...this.options, ...options };\r\n    }\r\n  }\r\n\r\n  updateComponent(deltaTime, currentTime) {\r\n    if (this.active) {\r\n      this.loop(deltaTime, currentTime);\r\n    }\r\n  }\r\n\r\n  loop(deltaTime, currentTime) {}\r\n\r\n  refresh() {}\r\n  setup() {}\r\n}\r\n\r\nexport default Component;\r\n","import { clamp } from \"@/Bundles/Utils/Numeric\";\r\n\r\n/**\r\n * A helper class to handle colors with rgba channels\r\n */\r\nclass RGB {\r\n  static Black = new RGB(0x000000);\r\n  static White = new RGB(0xffffff);\r\n  static Grey = new RGB(0x7f7f7f);\r\n  static LightGrey = new RGB(0xbfbfbf);\r\n  static DarkGrey = new RGB(0x3f3f3f);\r\n  static Red = new RGB(0xff0000);\r\n  static Green = new RGB(0x00ff00);\r\n  static Blue = new RGB(0x0000ff);\r\n  static Yellow = new RGB(0xffff00);\r\n  static Cyan = new RGB(0x00ffff);\r\n  static Fuchsia = new RGB(0xff00ff);\r\n\r\n  #r = 0;\r\n  #g = 0;\r\n  #b = 0;\r\n\r\n  #opacity = 1;\r\n\r\n  /**\r\n   * @param r The red value of this color from 0 to 255\r\n   * @param g The green value of this color from 0 to 255\r\n   * @param b The blue value of this color from 0 to 255\r\n   * @param opacity The opacity value of this color from 0 to 1\r\n   */\r\n  constructor(r, g, b, opacity) {\r\n    if (typeof r === \"number\" && g === undefined && b === undefined) {\r\n      let hex = r;\r\n\r\n      // Format RGB standard (ex: 0xFF8800)\r\n      this.#r = (hex >> 16) & 0xff;\r\n      this.#g = (hex >> 8) & 0xff;\r\n      this.#b = hex & 0xff;\r\n      this.#opacity = 1;\r\n    } else {\r\n      // Cas normal avec r, g, b séparés\r\n      this.#r = r ?? this.#r;\r\n      this.#g = g ?? this.#g;\r\n      this.#b = b ?? this.#b;\r\n      this.#opacity = opacity ?? this.#opacity;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the red channel from 0 to 255\r\n   */\r\n  get r() {\r\n    return this.#r;\r\n  }\r\n\r\n  /**\r\n   * Sets the red channel from 0 to 255\r\n   */\r\n  set r(r) {\r\n    this.#r = clamp(r, 0, 255);\r\n  }\r\n\r\n  /**\r\n   * Returns the green channel from 0 to 255\r\n   */\r\n  get g() {\r\n    return this.#g;\r\n  }\r\n\r\n  /**\r\n   * Sets the green channel from 0 to 255\r\n   */\r\n  set g(g) {\r\n    this.#g = clamp(g, 0, 255);\r\n  }\r\n\r\n  /**\r\n   * Returns the blue channel from 0 to 255\r\n   */\r\n  get b() {\r\n    return this.#b;\r\n  }\r\n\r\n  /**\r\n   * Sets the blue channel from 0 to 255\r\n   */\r\n  set b(b) {\r\n    this.#b = clamp(b, 0, 255);\r\n  }\r\n\r\n  /**\r\n   * Returns the opacity channel from 0 to 1\r\n   */\r\n  get opacity() {\r\n    return this.#opacity;\r\n  }\r\n\r\n  /**\r\n   * Sets the opacity channel from 0 to 1\r\n   */\r\n  set opacity(opacity) {\r\n    this.#opacity = opacity;\r\n  }\r\n\r\n  /**\r\n   * Returns an array with splitted rgba channels\r\n   */\r\n  get rgba() {\r\n    return [this.r, this.g, this.b, this.opacity];\r\n  }\r\n\r\n  /**\r\n   * Returns the hexadecimal representation of this color on 8 bits\r\n   */\r\n  get _toString() {\r\n    return (\r\n      \"#\" +\r\n      parseInt(this.r.toFixed(0)).toString(16).padStart(2, \"0\") +\r\n      parseInt(this.g.toFixed(0)).toString(16).padStart(2, \"0\") +\r\n      parseInt(this.b.toFixed(0)).toString(16).padStart(2, \"0\") +\r\n      parseInt(Math.floor(this.opacity * 255).toFixed(0))\r\n        .toString(16)\r\n        .padStart(2, \"0\")\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns a new Color which is the addition of this color with an other\r\n   * @param color The color to add to this color\r\n   * @returns Color\r\n   */\r\n  add(color) {\r\n    if (color instanceof RGB) {\r\n      return new RGB(\r\n        this.r + color.r,\r\n        this.g + color.g,\r\n        this.b + color.b,\r\n        this.opacity + color.opacity\r\n      );\r\n    } else if (typeof color === \"number\") {\r\n      return new RGB(\r\n        this.r + color,\r\n        this.g + color,\r\n        this.b + color,\r\n        this.opacity + color\r\n      );\r\n    } else {\r\n      throw (\r\n        \"Unable to compute a addition on the type '\" +\r\n        typeof color +\r\n        \"'. It should be a number or a Color\"\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new Color which is the multiplication of this color with an other\r\n   * @param color The color to multiply by this color\r\n   * @returns Color\r\n   */\r\n  multiply(color) {\r\n    if (color instanceof RGB) {\r\n      return new RGB(\r\n        Math.floor((this.r * color.r) / 0xff),\r\n        Math.floor((this.g * color.g) / 0xff),\r\n        Math.floor((this.b * color.b) / 0xff),\r\n        Math.floor(this.opacity * color.opacity)\r\n      );\r\n    } else if (typeof color === \"number\") {\r\n      return new RGB(\r\n        this.r * color,\r\n        this.g * color,\r\n        this.b * color\r\n        // this.opacity * color\r\n      );\r\n    } else {\r\n      throw (\r\n        \"Unable to compute a multiplication on the type '\" +\r\n        typeof color +\r\n        \"'. It should be a number or a Color\"\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Interpolates (linearly) this color to an other color. Calculates a value between those two colors at weight position\r\n   * @param color The other color to interpolate with\r\n   * @param weight The weight of the second vector in the computation. For exemple :\r\n   * 0 => returns the current color,\r\n   * 1 => returns the target color,\r\n   * 0.33 => returns the value of a new color at 33% between this color and the color parameter\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  lerp(color, weight, withOpacity = true) {\r\n    this.r = (1 - weight) * this.r + weight * color.r;\r\n    this.g = (1 - weight) * this.g + weight * color.g;\r\n    this.b = (1 - weight) * this.b + weight * color.b;\r\n    if (withOpacity) {\r\n      this.opacity = (1 - weight) * this.opacity + weight * color.opacity;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this vector\r\n   * @returns RGB\r\n   */\r\n  clone() {\r\n    return new RGB(this.r, this.g, this.b, this.opacity);\r\n  }\r\n\r\n  /**\r\n   * Copies the coordinates of a given vector to this vector\r\n   * @param v The vector to be copied\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  copy(v) {\r\n    if (v) {\r\n      this.r = v.r;\r\n      this.g = v.g;\r\n      this.b = v.b;\r\n      this.opacity = v.opacity;\r\n    }\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default RGB;\r\n","import { degreesToRadians, radiansToDegrees } from \"@/Bundles/Utils/Numeric\";\r\n\r\n/**\r\n * A helper class which angle rotation (i.e. angle) and simplify conversion to radians or degrees\r\n */\r\nclass Rotation {\r\n  static 30 = new Rotation(Math.PI / 6);\r\n  static 45 = new Rotation(Math.PI / 4);\r\n  static 90 = new Rotation(Math.PI / 2);\r\n  static 180 = new Rotation(Math.PI);\r\n  static 360 = new Rotation(Math.PI * 2);\r\n\r\n  #angle;\r\n\r\n  /**\r\n   * @param angle The angle of the rotation, can be in radians or degrees depending on the second parameter\r\n   * @param asRadian Indicates if the give 'angle' is in radians or in degrees\r\n   */\r\n  constructor(angle, asRadian) {\r\n    this.#angle = asRadian ? angle : degreesToRadians(angle);\r\n  }\r\n\r\n  /**\r\n   * Returns the current angle in radians\r\n   */\r\n  get angle() {\r\n    return this.#angle;\r\n  }\r\n\r\n  /**\r\n   * Sets the current angle to 'angle' value, have to be in radians\r\n   * @param angle The angle of the rotation, can be in radians or degrees depending on the second parameter\r\n   * @param asRadian Indicates if the give 'angle' is in radians or in degrees\r\n   */\r\n  setAngle(angle, asRadian) {\r\n    this.#angle = asRadian ? angle : degreesToRadians(angle);\r\n  }\r\n\r\n  /**\r\n   * Returns the current angle in radians\r\n   */\r\n  get toRadians() {\r\n    return this.angle;\r\n  }\r\n\r\n  /**\r\n   * Returns the current angle in degrees\r\n   */\r\n  get toDegrees() {\r\n    return radiansToDegrees(this.angle);\r\n  }\r\n\r\n  /**\r\n   * Adds a rotation to current angle\r\n   * @param rotation The Rotation to add\r\n   * @returns The addition of these two angles\r\n   */\r\n  add(rotation) {\r\n    return new Rotation(this.angle + rotation.angle, true);\r\n  }\r\n\r\n  /**\r\n   * Substracts a rotation to current angle\r\n   * @param rotation The Rotation to substract\r\n   * @returns The substraction of these two angles\r\n   */\r\n  sub(rotation) {\r\n    return new Rotation(this.angle - rotation.angle, true);\r\n  }\r\n\r\n  /**\r\n   * Inverts the angle (multiply by * -1)\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  invert() {\r\n    this.#angle = -this.angle;\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default Rotation;\r\n","import { clamp } from \"@/Bundles/Utils/Numeric\";\r\nimport { Rotation } from \"@/Bundles/Core\";\r\n\r\nclass Vector2 {\r\n  static X = new Vector2(1, 0);\r\n  static Y = new Vector2(0, 1);\r\n  static O = new Vector2(0, 0);\r\n  static ONE = new Vector2(1, 1);\r\n\r\n  #x = 0;\r\n  #y = 0;\r\n\r\n  constructor(x = 0, y = 0) {\r\n    this.#x = x;\r\n    this.#y = y;\r\n  }\r\n\r\n  /* ========== Getters ========== */\r\n\r\n  /**\r\n   * Returns the x coordinate of this vector\r\n   */\r\n  get x() {\r\n    return this.#x;\r\n  }\r\n\r\n  /**\r\n   * Returns the y coordinate of this vector\r\n   */\r\n  get y() {\r\n    return this.#y;\r\n  }\r\n\r\n  /**\r\n   * Returns the length (or magnitude) of this vector\r\n   */\r\n  get length() {\r\n    return Math.sqrt(this.squid);\r\n  }\r\n\r\n  /**\r\n   * Returns the squared Euclidian distance of this vector\r\n   */\r\n  get squid() {\r\n    return this.x ** 2 + this.y ** 2;\r\n  }\r\n\r\n  /**\r\n   * Returns a normalized copy of this vector (a vector with the same direction with a magnitude/length of 1 unit)\r\n   */\r\n  get normalized() {\r\n    if (this.length === 0) {\r\n      return Vector2.O;\r\n    }\r\n    return this.clone().divide(this.length);\r\n  }\r\n\r\n  /**\r\n   * Returns the rotation of this vector (i.e. from origin to this vector, which value is the angle (in radian) between by X axis and this vector)\r\n   * Refer to Rotation doc for more information\r\n   */\r\n  get rotation() {\r\n    return new Rotation(Math.atan2(this.y, this.x), true);\r\n  }\r\n\r\n  /* ========== Setters ========== */\r\n\r\n  /**\r\n   * Defines the x coordinate of this vector\r\n   */\r\n  set x(x) {\r\n    this.#x = x;\r\n  }\r\n\r\n  /**\r\n   * Defines the y coordinate of this vector\r\n   */\r\n  set y(y) {\r\n    this.#y = y;\r\n  }\r\n\r\n  /* ========== Modifiers ========== */\r\n\r\n  /* ===== Basic operations ===== */\r\n\r\n  /**\r\n   * Computes an addition between coordinates of this vector and a number or another vector.\r\n   * If value is a number, adds value to x and y coordinates\r\n   * If value is a vector, adds value.x to x coordinates and value.y to y coordinates\r\n   * @param v Can be a vector or a number\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  add(value) {\r\n    if (value instanceof Vector2) {\r\n      this.x += value.x;\r\n      this.y += value.y;\r\n    } else if (typeof value === \"number\") {\r\n      this.x += value;\r\n      this.y += value;\r\n    } else {\r\n      throw (\r\n        \"Unable to compute a addition on the type '\" +\r\n        typeof value +\r\n        \"'. It should be a number or a Vector2\"\r\n      );\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Computes a substraction between coordinates of this vector and a number or another vector.\r\n   * If value is a number, substracts value to x and y coordinates\r\n   * If value is a vector, substracts value.x to x coordinates and value.y to y coordinates\r\n   * @param v Can be a vector or a number\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  sub(value) {\r\n    if (value instanceof Vector2) {\r\n      this.x -= value.x;\r\n      this.y -= value.y;\r\n    } else if (typeof value === \"number\") {\r\n      this.x -= value;\r\n      this.y -= value;\r\n    } else {\r\n      throw (\r\n        \"Unable to compute a subsraction on the type '\" +\r\n        typeof value +\r\n        \"'. It should be a number or a Vector2\"\r\n      );\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Computes a division between coordinates of this vector and a number or another vector.\r\n   * If value is a number, divides value to x and y coordinates\r\n   * If value is a vector, divides value.x to x coordinates and value.y to y coordinates\r\n   * @param v Can be a vector or a number\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  divide(value) {\r\n    if (value instanceof Vector2) {\r\n      this.x /= value.x;\r\n      this.y /= value.y;\r\n    } else if (typeof value === \"number\") {\r\n      this.x /= value;\r\n      this.y /= value;\r\n    } else {\r\n      throw (\r\n        \"Unable to compute a division on the type '\" +\r\n        typeof value +\r\n        \"'. It should be a number or a Vector2\"\r\n      );\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Computes a multiplication between coordinates of this vector and a number or another vector.\r\n   * If value is a number, multiplies value to x and y coordinates\r\n   * If value is a vector, multiplies value.x to x coordinates and value.y to y coordinates\r\n   * @param v Can be a vector or a number\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  multiply(value) {\r\n    if (value instanceof Vector2) {\r\n      this.x *= value.x;\r\n      this.y *= value.y;\r\n    } else if (typeof value === \"number\") {\r\n      this.x *= value;\r\n      this.y *= value;\r\n    } else {\r\n      throw (\r\n        \"Unable to compute a multiplication on the type '\" +\r\n        typeof value +\r\n        \"'. It should be a number or a Vector2\"\r\n      );\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /* ===== Complex operations ===== */\r\n\r\n  /**\r\n   * Clamps the magnitude/length of this vector to a maximum.\r\n   * If current length of this vector is smaller than length parameter, the vector remains the same\r\n   * If current length of this vector is greater than length paramter, the vector is limited to this value\r\n   * @param length A maximum magnitude/length that this vector can overtake\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  clampLength(length) {\r\n    if (length === 0) {\r\n      this.copy(Vector2.O);\r\n    }\r\n\r\n    this.copy(this.normalized.multiply(Math.min(this.length, length)));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Normalizes the vector. It means that the vector will have the same direction but with a magnitude/length of 1 unit\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  normalize() {\r\n    let normalized = this.normalized;\r\n    this.x = normalized.x;\r\n    this.y = normalized.y;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Interpolates (linearly) this vector to an other vector. Calculates a point between those two vectors at weight position\r\n   * @param target The other vector to interpolate with\r\n   * @param weight The weight of the second vector in the computation. For exemple :\r\n   * 0 => returns the current vector,\r\n   * 1 => returns the target vector,\r\n   * 0.33 => returns the position of a new vector at 33% between this vector and the target\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  lerp(target, weight) {\r\n    weight = clamp(weight, 0, 1);\r\n    this.x = (1 - weight) * this.x + weight * target.x;\r\n    this.y = (1 - weight) * this.y + weight * target.y;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Inverts the current vector into the opposite direction\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  invert() {\r\n    this.x = -this.x;\r\n    this.y = -this.y;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Rotates the current vector by an angle (given as Rotation object).\r\n   * Refer to Rotation doc for more information\r\n   * @param angle A Rotation object to simplify angle handling\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  rotate(angle) {\r\n    let x =\r\n      Math.cos(angle.toRadians) * this.x - Math.sin(angle.toRadians) * this.y;\r\n    let y =\r\n      Math.sin(angle.toRadians) * this.x + Math.cos(angle.toRadians) * this.y;\r\n    this.x = x;\r\n    this.y = y;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns the dot product of this vector and another\r\n   * @param v The other vector to compute with\r\n   * @returns number The result of the dot product between those two vectors\r\n   */\r\n  dot(v) {\r\n    if (!(v instanceof Vector2))\r\n      throw \"Unable to compute a dot product on non Vector2 object\";\r\n    return this.x * v.x + this.y * v.y;\r\n  }\r\n\r\n  /* ========== Miscellaneous ========== */\r\n\r\n  /* ===== Assigning ===== */\r\n\r\n  /**\r\n   * Returns a clone of this vector\r\n   * @returns Vector2\r\n   */\r\n  clone() {\r\n    return new Vector2(this.x, this.y);\r\n  }\r\n\r\n  /**\r\n   * Copies the coordinates of a given vector to this vector\r\n   * @param v The vector to be copied\r\n   * @returns this Returns this for methods chaining\r\n   */\r\n  copy(v) {\r\n    if (v) {\r\n      this.x = v.x;\r\n      this.y = v.y;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /* ========== Static methods ========== */\r\n\r\n  /**\r\n   * Returns an object with \"to\" property which is a function that takes as parameters a vector and returns a vector.\r\n   * The usefulness of these function is to return a directional vector between two vectors as so :\r\n   * Vector2.from(origin).to(target);\r\n   * @param origin\r\n   */\r\n  static from(origin) {\r\n    return {\r\n      to: (target) => target.clone().sub(origin),\r\n    };\r\n  }\r\n}\r\n\r\nexport default Vector2;\r\n"],"names":["clamp","degreesToRadians","radiansToDegrees"],"mappings":"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"}